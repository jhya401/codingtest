package inflearnCodingTest.DfsDfs;

/**
 * 07-04. 피보나치 재귀(메모이제이션)
 * #재귀함수 #피보나치
 */

/**
 * ⭐️코테 단골질문: 피보나치를 재귀로 구현하는 것과 for로 구현하는 것 중 뭐가 더 유리한가?
 * -> 당연히 for 문이 더 유리하다.
 *    why? 재귀함수는 스택 프레임을 사용하기 때문에이다. 재귀함수를 호출 할 때 마다 스택 프레임을 생성해야 한다.
 *    for 문을 사용하면 스택 프레임은 단 1개만 생기는 것이고, 단지 지역함수를 이용하는 것이기 때문에 비용이 훨씬 적게 든다!
 * 참고: for문과 배열로 구현하는 피보나치 예제 (02-04 피보나치 수열)
 *
 * ⭐️ 재귀함수로도 빠르게 구현하기 = 메모이제이션 사용
 * ▶️ 단순히 재귀만 쓰면 느리다.
 * ▶️ 근데 메모이제이션(캐싱)을 이용하면 매우 빠르다.
 * ▶️ 그래도 for 문 이용하는게 더 빠르다.
 */

/**
 * 문제
 * 피보나치 수열을 출력한다.
 * 피보나치 수열이란 앞의 2개 수를 합하여 다음 숫자가 되는 수열이다.
 * 입력은 피보나치 수열의 총 항의 수 이다.
 * 만약 7이 입력되면 1 1 2 3 5 8 13 을 출력한다
 * 입력설명
 * 첫 줄에 총 항수 N(3<=N<=45)이 입력된다.
 * 입력예제
 * 10
 * 출력예제
 * 1 1 2 3 5 8 13 21 34 55
 */
public class DfsBfs04 {

    private static int[] fibo;

    /**
     * 피보나치 재귀로 구현시 단점: 항 갯수가 많아지면 너무 느려진다.
     *  예를들어 45만 넣어도 엄청 오래 걸린다.
     */
    public static void main(String[] args) {
        int N = 45;

        /* 단순한 피보나치 재귀(쓰지말자)
        // N번째 항의 값만 출력
        System.out.print(dfs(N));
        System.out.println("");

        // N번째 항까지의 모든 피보나치 수열 출력 => 느림
        for (int i = 1; i <= N; i++) {
            System.out.print(dfs(i) + " ");
        }
        System.out.println("");*/

        // 메모이제이션 사용하기
        fibo = new int[N+1];
        dfsCash(N);
        for (int i = 1; i <= N; i++) {
            System.out.print(fibo[i] + " ");
        }
    }

    /**
     * 피보나치 구현2 : ⭐️메모이제이션 방법! 매우 빠름‼
     * 컨셉: 이미 구했던 항은 메모리에 저장 후 다시 같은 항을 호출하면 즉시 메모리에 저장된 값을 반환한다.
     *      즉, 메모리에 있는 값은 계산(=재귀함수호출)하지 않으므로 매우 빠르다.
     */
    private static int dfsCash(int N) {
        if (N == 1) return fibo[N] = 1; // 첫번째 항은 항시 1이다.
        if (N == 2) return fibo[N] = 1; // 두번째 항도 항시 1이다.
        else {
            // ⭐️ 이 부분이 핵심! index=항, value=피보나치수
            // 메모리에 캐싱된 데이터가 있다면 그 값을 바로 리턴한다.
            if (fibo[N] != 0) return fibo[N];

            // 세번째 항부터는 달라진다.
            return fibo[N] = dfsCash(N - 2) + dfsCash(N - 1);
        }
    }

    /**
     * 피보나치구현1 : ‼️너무 느려! 쓰지말아야 함.
     * N은 몇번째 항인지 위치를 나타낸다.
     * #피보나치 #피보나치수열구하는함수
     */
    private static int dfs(int N) {
        if (N == 1) return 1; // 첫번째 항은 항시 1이다.
        if (N == 2) return 1; // 두번째 항도 항시 1이다.

        // 세번째 항부터는 달라진다.
        return dfs(N - 2) + dfs(N - 1);
    }
}
